//<카드 다시 정리>
//
//1. 박스 최대 1개는 조커 박스로 지정
// 
// (조커박스는 색이 다른 카드를 보관 가능)
// 
//2. 조커 박스를 제외한 나머지 모든 박스가 비어 있거나
// 
// 같은색의 가드만 보관
// 
//3. 같은 색을 가진 모든 카드는 모두 같은 박스
// 
//이때 조커 박스에 들어있는 카드 제외, 
// 
// 같은 색을 가진 모든 카드가 조커 박스에 들어있는 것도 가능.
//
//
// <입력> : 박스 갯수 N, 색상 갯수 M
// N개의 줄에 한 박스에 들어있는 카드 정보가 주어짐
// 
// 카드 정보는 M개 
// 행렬 = N*M
// 
// ----------------------------------------
// 추가로, 내가 조커 박스를 정하면 됨,
// 뭔가 조건에 부합 하지 않는 것 만 따로 빼서
// 이동 조건을 최소로 하는 방법을 찾으면 됨,
// ----------------------------------------
//
// plan : 몇번 이동해야 3번 지킴?
// 
// 일단 각 박스를 조커로, 

// 카드가 2개 이상이다? 무조건 이동 해야됨 +1

// 처음에 나온 카드가 딱 1개다, 그럼 그 카드는 이제

// 구분하는 용도의 카드가 되는거임

// 근데 만약 다른 박스에서도 카드가 딱 1개인데 종류가

// 이미 전에 있던 종류다, 

// 그럼 바로 +1 해주고 넘기기
// 
// 이때 카드 갯수를 새는 건 의미가 없음, 그냥 값이 있으면 1 없으면 0으로
// 
// brute force + greedy?
//
//-----------------------------------------------------
// (AM 08:00) 본인은 각각의 박스를 조커일때로 경우를 잡아
// 브루트 포스로 돌리는 걸로 결정함
//-----------------------------------------------------
//
//Problem_Solving_Time : AM 07:00 - AM 08:33
//
//

#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#define min(x, y) ((x) < (y) ? (x) : (y)) // define min_function

int n, m, certi_box = 0;
// n, m은 문제와 같다
//certi box 는 kind 함수의 보조 역할 (후에 설명)

int kind(bool* arr) {
	int k = 0;
	for (int i = 0; i < m; i++) {
		if (arr[i]) {
			k++;
			if (k == 1) {
				certi_box = i;
			}
			else {
				return 2;
			}
		}
	}
	return (k != 0 ? 1 : 0);
}
//kind 함수는 box 의 한 줄, 즉 한 열(행과 열의 열) 을 받아서 
// 그 i 번째 박스에는 어떤 카드가 들어있는지 찾고,
// 2개 이상이면 2, 1개면 1, 없으면 0 을 반환하며
//이때 certi_box는 k == 1일때 이 박스는 certi_box 번째 카드 전용 박스로
//설정 하기 위한 역할을 해준다.


int main(void) {

	int ans;
	scanf("%d %d", &n, &m);
	ans = n * m;
	// 정답은 가장 크게, 즉 n*m 이면 충분 하다

	bool* seen = (bool*)malloc(sizeof(bool) * m);
	//1. 메모리 관리를 위해 동적을 m 만큼 할당해준다.
	//2. 현재 k 번째의 카드 전용 박스가 있는지 없는지 반환 시키는 용도로써
	// 배열을 설정 하였다.

	for (int i = 0; i < m; i++) seen[i] = false;
	// 초기화

	bool** box = (bool**)malloc(sizeof(bool*) * n);
	//이 2차원 box배열은 입력받을때
	//어떤 식으로 받았는지 저장하기 위해 
	//"맵"(말 그대로 본래의 지도 역할)백업본을 n*m만큼
	//동적할당하여 입력값을 넣어 주었다.

	for (int i = 0; i < n; i++) {
		box[i] = (bool*)malloc(sizeof(bool) * m);
		for (int j = 0; j < m; j++) box[i][j] = false;
	}

	for (int i = 0; i < n; i++) {
		for (int j = 0, x; j < m; j++) {
			scanf("%d", &x);
			box[i][j] = (x > 0 ? true : false);
			// 생각해보면, 어짜피 한번에 카드를 몽땅 옮긴다
			// 심지어 옮길때 패널티가 없고,
			// 한번에 카드를 몽땅 옮길때, 나누어 주어도 상관이 없다.
			// 고로 이는 갯수는 상관이 없고
			// 그냥 얼만큼 카드 덩어리를 분배시키면
			// 최소로 옮기는지 에 대해 알 수 있다.
		}
	}// 이때 입력값을 받는 곳을 작성하면서
	// "이거 브루트 포스로 되겠는데 ? "라고 생각했다.



	for (int i = 0; i < n; i++) {


		// i 는 사실상 "box[i] 가 조커이다" 를 가정하기 위한 장치 이고,
		// 이 부분에서 브루트 포스를 사용하였다.

		int mv = 0;

		// 무브는 각 분기당 (각 box[i]를 조커라 가정 했을 분기)
		//얼만큼 이동했는지의 카운트 역할을 해주고, 
		// 나중에 ans 변수와 comparison 하여 작은 값을 ans 에 반환 시킨다

		for (int k = 0; k < m; k++) seen[k] = false;
		// 매번 돌릴때 마다 어느 쪽에서 "i 번째 카드 전용 박스"
		// 가 되는지 확인하기 위한 seen 변수를 초기화 시킨다
		// (다시 말하지만, seen 변수는 "어느 쪽에서 이미 i 번째 카드 전용 박스가 됬는지 안됬는지"
		// 를 파악하기 위한 장치 이다)


		for (int j = 0; j < n; j++) {
			certi_box = 0;
			if (j == i) continue;

			int kind_of_box = kind(box[j]);

			if (kind_of_box >= 2) mv++;

			else if (kind_of_box == 1) {
				seen[certi_box] ? mv++ : (seen[certi_box] = true);
			}

		}

// < 밑의 주석은 이미 32줄에 먼저 생각하면서 적어 놓았으며 위 for문 코드는 이를 구현 한 것이다.>

// 일단 각 박스를 조커로, 

// 카드가 2개 이상이다? 무조건 이동 해야됨 +1

// 처음에 나온 카드가 딱 1개다, 그럼 그 카드는 이제

// 구분하는 용도의 카드가 되는거임

// 근데 만약 다른 박스에서도 카드가 딱 1개인데 종류가

// 이미 전에 있던 종류다, 

// 그럼 바로 +1 해주고 넘기기

		ans = min(ans, mv);
	}
	printf("%d", ans);

	return 0;
}
